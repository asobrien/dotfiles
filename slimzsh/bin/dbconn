#!/usr/bin/env python
 # -*- coding: utf-8 -*-

"""
    dbconn
    ~~~~~~
    A small utility script to parse pillar data and connect to databases.

"""

import os
import sys
import tempfile

try:
    import yaml
except ImportError:
    sys.stderr.write('Cannot import pyyaml, this can be installed by running: \n'
                     '    `pip install --user pyyaml`\n')
    sys.exit(1)

# Create a raw_input function in python3+
__is_py3 = sys.version_info[0] > 2  # is this running in python 3
if __is_py3:
    def raw_input(string):
        return input(string)


PILLAR_PATH = os.getenv('PILLAR_PATH')

if PILLAR_PATH is None:
    sys.stderr.write('$PILLAR_PATH is not defined\n')
    sys.exit(1)


# Expand and get abspath
PILLAR_PATH = os.path.abspath(
              os.path.expandvars(
              os.path.expanduser(PILLAR_PATH)))


#: Client configuration template
MYSQL_CONF_TEMPLATE = """
[client]
host     = {}
user     = {}
password = {}
"""

def __get_env(environment):
    """Returns an env name for the proper pillar environment."""
        # envs have different slang, unify them here
    env = environment.lower()
    env_map = {
        'dev': ['develop', 'development'],
        'stg': ['stage', 'staging'],
        'prd': ['prod', 'production']}

    for key, vals in env_map.iteritems():
        if env == key or env in vals:
            return key
    sys.stderr.write('Unknown environmet ({}) specified\n'.format(env))
    sys.exit(1)


def __load_data(environment):
    """Loads the pillar data as dictionary for the specified `environment`.

    Currently only MySQL database information is returned.

    """
    env = __get_env(environment)
    sls_file = os.path.join(PILLAR_PATH, '{}/settings/rds.sls'.format(env))
    with open(sls_file, 'r') as f:
        data = yaml.load(f.read())
    # create enumuerated data?
    return data['db_instances']['mysql']


def __enumerate_data(data):
    """Creates an enumerated dictionary from data."""
    enum_data = {i:key for i, key in enumerate(sorted(data))}
    return enum_data


def __pprint_databases(enum_data):
    """Pretty prints databases to stdout, with the following format:

    [0]  database-name
    [1]  other-database-name

    """
    for key, val in enum_data.iteritems():
        sys.stdout.write('[{}]  {}\n'.format(key, val))


def main():
    """With `environment` specified, this prompts for database to connect
    to and then initiates the connection.

    If no environment is specified, then first and environment will be prompted
    for.
    """
    # get the environment
    if len(sys.argv) > 1:
        env = __get_env(sys.argv[1])
    else:
        env = __get_env(raw_input('Specify environment: '))

    data = __load_data(env)
    enum_data = __enumerate_data(data)

    # print choice block
    sys.stdout.write('\nThe following databases are available in '
                     '{} ...\n\n'.format(env.upper()))
    __pprint_databases(enum_data)
    choice = int(raw_input('\nEnter choice: '))

    db_key = enum_data[choice]  # get the key from the choice
    db = data[db_key]  # get the db credentials

    # Initiate the connection
    # this tempfile exists for the duration of the connection
    with tempfile.NamedTemporaryFile(bufsize=0) as conf_file:

        # format the host
        if env in ('prod',):
            host = '{}.longtailvideo.com'.format(db_key)
        else:
            host = '{}.{}.longtailvideo.com'.format(db_key, env)

        conf_file.file.write(MYSQL_CONF_TEMPLATE.format(host,
                                                   db['root_user'],
                                                   db['root_password']))

        # spawn the connection
        sys.stdout.write('\nConnecting to {} ...\n\n'.format(host))
        os.system('mysql --defaults-file={}'.format(conf_file.name))


if __name__ == '__main__':
    main()
